#!/usr/bin/python
"""Convert matrices into graphviz .dot files.
"""
import numpy as np
import sys

# boolean class enumation key
BOOL_ENUM = {0:'NA', 1:'XiY', 2:'PC', 3:'YiX', 4:'UNL', 5:'MX', 6:'NC', 7:'OR'}

# GRAPHVIZ TEMPLATES
FONT_STRING = """graph [fontname = "helvetica"];
node [fontname = "helvetica"];
edge [fontname = "helvetica", penwidth=1];"""
DFT_PTN_NODE_STYLE = '"%s"[color="%s",style=filled,fontcolor=white]'

def str_true_false(s):
  if not s:
    return False
  if isinstance(s,basestring) and s.lower() in ("f","false","none","null"):
    return False
  return True

def load_colors_as_node_style_dict(fp):
  """Load fp of ;-delimited node name to #xxxxxx color mappings as node style dict."""
  q = {}
  for s in fp:
    s = s.strip("\n\r")
    if not (len(s)>0 and s[0]!="#"): continue
    node, color = s.split(';')
    q[node] = {'color':color}
  return dict(q)

def node_style_dict_to_str(d):
  d.setdefault("style", "filled")
  d.setdefault("fontcolor", "white")
  s = ", ".join(('%s="%s"'%(k,v) for k,v in d.items()))
  return s

def print_graphviz(names, out=sys.stdout, node_styles=None, graph_type="digraph", prefix="", postfix="", **kwds):
  """Print graphviz output to `out` stream.
  See `yield_matrix_to_edge_dict` for additional options passed via **kwds.
  """
  # Print header.
  print >>out, "%s {" % (graph_type)
  if prefix: print >>out, prefix
  print >>out, FONT_STRING
  # Print node styles.
  if node_styles is not None:
    name_set = set(names)
    for node_name, style_d in node_styles.items():
      if node_name not in name_set:
        print >>sys.stderr, "WARNING: node name %s not in list of edge names." % node_name
      print >>out, '"%s" [%s]' % (node_name, node_style_dict_to_str(style_d))
  # Print edges
  for d in yield_matrix_to_edge_dict(names, **kwds):
    if d:
      print >>out, edge_attr_to_line(d)
  # Print footer.
  if postfix: print >>out, postfix
  print >>out, "}"

def yield_matrix_to_edge_dict(names=None, CLS=None, DCOR=None, WEAK=None, min_d=0.3, weighted=True, plot_na=False):
  """Yield graphviz edge dict from adj matrices and list of names. Return None if no edge."""
  assert names is not None and CLS is not None and DCOR is not None
  assert np.size(CLS,0) == np.size(CLS,1)
  assert np.shape(CLS) == np.shape(DCOR)
  assert len(names) == np.size(CLS,0)
  if WEAK is not None:
    assert np.shape(CLS) == np.shape(WEAK)
  n = np.size(CLS,0)
  assert n>1
  for i in xrange(n-1):
    for j in xrange(i+1,n):
      cls, dcor = CLS[i,j], DCOR[i,j]
      if WEAK is not None:
        weak = WEAK[i,j]
      else:
        weak = None
      if weighted:
        weight = dcor
      else:
        weight = None
      d = get_edge_dict(\
            rowname=names[i], colname=names[j], cls=cls, dcor=dcor,\
            weak_cls=weak, min_dcor=min_d, plot_na=plot_na, weight=weight)
      yield d

def edge_attr_to_line(d):
  """Given an edge dictionary generated by get_edge_dict, return graphviz string."""
  e = '"%s" -> "%s"' % (d['source'], d['dest'])
  a = ", ".join(("%s=%s"%(k,v) for k,v in d['attr'].items()))
  return "%s[%s];" % (e,a)
    
def get_edge_dict(rowname, colname, cls, dcor, weak_cls=None, min_dcor=0, plot_na=False, weight=None):
  """Return an attribute dict describing an edge. Return None if no edge."""
  assert cls in BOOL_ENUM.keys(); assert dcor >= 0 and dcor <= 1;
  assert min_dcor >= 0 and min_dcor <= 1
  assert rowname and colname
  if weight is not None:
    if not isinstance(weight, basestring):
      weight = "%f"%weight
  
  # Edge Filtering
  # ------------------------------
  if not plot_na and cls == 0:
    return None
  if cls not in (0,1,2,3,4):
    return None
  if dcor < min_dcor:
    return None
    
  # Edge Direction
  # ------------------------------
  d = {}
  if cls == 3: # edge goes opposite direction
    d['source'] = colname; d['dest'] = rowname
  elif cls == 4 and weak_cls is not None:
    pass     # this is not yet implemented
  else:      # edge goes from row to column (or is undirected)
    d['source'] = rowname; d['dest'] = colname

  # Edge Attributes
  # ------------------------------
  d['attr'] = {"penwidth":penwidth(cls,dcor), "color":'"%s"'%edgecolor(cls,dcor)}
  if weight is not None:
    d['attr']["weight"] = weight
  if cls == 0:
    d['attr'].update({'dir':"none", "constraint":"false", "style":"dotted"})
  elif cls == 2:
    d['attr'].update({'dir':"none", "constraint":"false"})
  elif cls == 4:
    if weak_cls is not None:
      pass # this is not yet implemented
    else:
      d['attr'].update({'dir':"none", "constraint":"false", "style":"dashed"})
  # RETURN EDGE DICT
  return d

def penwidth(c,d):
  """Return an edge pen width string from class `c` and dcor `d`."""
  assert c in BOOL_ENUM.keys(); assert d >= 0 and d <= 1
  if c==1 or c==3 or c==4:
    if d > 0.85:   return "1.5"
    else:          return "1.0"
  elif c == 2:
    if d > 0.9:    return "2.5"
    elif d > 0.8:  return "2.0"
    else:          return "1.5"
  else:
    return "1.0"

def edgecolor(c,d):
  """Return an edge color string from class `c` and dcor `d`."""
  assert c in BOOL_ENUM.keys(); assert d >= 0 and d <= 1
  if c == 0:
    return "#cccccc"
  elif c == 2:      # Positive Correlation (PC) class
    if d > 0.9:   return "#2688bf" # dark blue
    elif d > 0.8: return "#4197c7" # medium blue
    else:         return "#64acd4" # light blue
  elif c == 4:
    return "#888888"
  else:           # All other edges
    return "#222222"   # almost black

