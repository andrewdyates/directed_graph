#!/usr/bin/python
"""Convert matrices into graphviz .dot files.
"""
import numpy as np
import sys

# boolean class enumation key
BOOL_ENUM = {0:'NA', 1:'XiY', 2:'PC', 3:'YiX', 4:'UNL', 5:'MX', 6:'NC', 7:'OR'}
# 0: no class; 1: and; 2: rn4c (row necessary for col); 3: cn4r (col necessary for row); 4: xor; 5: mix
WEAK_ENUM = {0:'nc', 1:'and', 2:'rn4c', 3:'cn4r', 4:'xor', 5:'mix'}

# GRAPHVIZ TEMPLATES
FONT_STRING = """graph [fontname = "helvetica"];
node [fontname = "helvetica"];
edge [fontname = "helvetica", penwidth=1];"""
DFT_PTN_NODE_STYLE = '"%s"[color="%s",style=filled,fontcolor=white]'

def str_true_false(s):
  if not s:
    return False
  if isinstance(s,basestring) and s.lower() in ("f","false","none","null"):
    return False
  return True

def load_clusters(fp):
  """Load cluster node_name,enumeration from csv file pointer."""
  C = {}
  for line in fp:
    name, enum = (s.strip('" ') for s in line.strip('\r\n').split(','))
    C.setdefault(enum,set()).add(name)
  return C

def load_colors_as_node_style_dict(fp):
  """Load fp of ;-delimited node name to #xxxxxx color mappings as node style dict."""
  q = {}
  for s in fp:
    s = s.strip("\n\r")
    if not (len(s)>0 and s[0]!="#"): continue
    node, color = s.split(';')
    q[node] = {'color':color}
  return dict(q)

def node_style_dict_to_str(d):
  d.setdefault("style", "filled")
  d.setdefault("fontcolor", "white")
  s = ", ".join(('%s="%s"'%(k,v) for k,v in d.items()))
  return s

def edge_list_to_adjM_dict(G):
  """Return A[source][dest] adj matrix."""
  A = {}
  nodes = G['nodes']
  for s in sorted(nodes):
    A[s] = {}
  for e in G['edges']:
    s,d = e['source'], e['dest']
    A[s][d] = e
    if not e['directed']:
      A[d][s] = e
  return A

def edge_list_to_adjMs(G):
  """Export graph dict returned from print_graphviz to csv."""
  A = edge_list_to_adjM_dict(G)
  nodes = G['nodes']
  node_idx = dict(( (s,i) for i,s in enumerate(nodes) ))
  n = len(nodes)
  Adj = np.zeros((n,n), dtype=np.bool)
  Weak = np.zeros((n,n), dtype=np.bool)
  Cor = np.zeros((n,n), dtype=np.bool)
  for s in A:
    for d,e in A[s].items():
      i,j = node_idx[s], node_idx[d]
      Adj[i,j] = True
      if e['cls'] == 2:
        Cor[i,j] = True; Cor[j,i] = True
      if e['cls'] == 4:
        Weak[i,j] = True; Weak[j,i] = True
  return {'Adj':Adj, 'nodes':nodes, 'Cor':Cor, 'Weak':Weak}

def adjM_to_out(out, Adj, nodes):
  """Print Adjacency matrix to out as csv."""
  print >>out, ",".join([""]+nodes)
  for i, row in enumerate(Adj):
    r = [str(int(r)) for r in row]
    print >>out, ",".join([nodes[i]]+r)
  
def print_graphviz(names, out=sys.stdout, node_styles=None, graph_type="digraph", prefix="", postfix="", **kwds):
  """Print graphviz output to `out` stream.
  Return dict of edge and node representation
  See `yield_matrix_to_edge_dict` for additional options passed via **kwds.
  """
  # Print header.
  print >>out, "%s {" % (graph_type)
  if prefix: print >>out, prefix
  print >>out, FONT_STRING
  # Print node styles.
  if node_styles is not None:
    name_set = set(names)
    for node_name, style_d in node_styles.items():
      if node_name not in name_set:
        print >>sys.stderr, "WARNING: node name %s not in list of edge names." % node_name
      print >>out, '"%s" [%s]' % (node_name, node_style_dict_to_str(style_d))
  # Print edges
  G = {'nodes':names, 'edges':[]}
  for d in yield_matrix_to_edge_dict(names, **kwds):
    if d:
      print >>out, edge_attr_to_line(d)
      G['edges'].append(d)
  # Print footer.
  if postfix: print >>out, postfix
  print >>out, "}"
  return G

def yield_matrix_to_edge_dict(names=None, CLS=None, DCOR=None, WEAK=None, min_d=0.3, weighted=True, plot_na=False, **kwds):
  """Yield graphviz edge dict from adj matrices and list of names. Return None if no edge."""
  assert names is not None and CLS is not None and DCOR is not None
  assert np.size(CLS,0) == np.size(CLS,1)
  assert np.shape(CLS) == np.shape(DCOR)
  assert len(names) == np.size(CLS,0)
  if WEAK is not None:
    assert np.shape(CLS) == np.shape(WEAK)
  n = np.size(CLS,0)
  assert n>1
  for i in xrange(n-1):
    for j in xrange(i+1,n):
      cls, dcor = CLS[i,j], DCOR[i,j]
      if WEAK is not None:
        weak = WEAK[i,j]
      else:
        weak = None
      if weighted:
        weight = dcor
      else:
        weight = None
      d = get_edge_dict(\
            rowname=names[i], colname=names[j], cls=cls, dcor=dcor,\
            weak_cls=weak, min_dcor=min_d, plot_na=plot_na, weight=weight)
      yield d

def edge_attr_to_line(d):
  """Given an edge dictionary generated by get_edge_dict, return graphviz string."""
  e = '"%s" -> "%s"' % (d['source'], d['dest'])
  a = ", ".join(("%s=%s"%(k,v) for k,v in d['attr'].items()))
  return "%s[%s];" % (e,a)
    
def get_edge_dict(rowname, colname, cls, dcor, weak_cls=None, min_dcor=0, plot_na=False, weight=None):
  """Return an attribute dict describing an edge. Return None if no edge."""
  assert cls in BOOL_ENUM.keys(); assert dcor >= 0 and dcor <= 1;
  assert min_dcor >= 0 and min_dcor <= 1
  assert rowname and colname
  if weight is not None:
    if not isinstance(weight, basestring):
      weight = "%f"%weight
  
  # Edge Filtering
  # ------------------------------
  if not plot_na and cls == 0:
    return None
  if cls not in (0,1,2,3,4):
    return None
  if dcor < min_dcor:
    return None
    
  # Edge Direction
  # ------------------------------
  d = {'cls':int(cls), 'dcor':dcor, 'weak':int(weak_cls), 'is_weak':False}
  if cls == 1:
    d['source'] = rowname; d['dest'] = colname
    d['directed'] = True
  elif cls == 3: # edge goes opposite direction
    d['source'] = colname; d['dest'] = rowname
    d['directed'] = True
  elif cls == 4 and weak_cls is not None:
    # WEAK_ENUM = {0:'nc', 1:'and', 2:'rn4c', 3:'cn4r', 4:'xor', 5:'mix'}
    if weak_cls == 0 or weak_cls == 4: # no class or xor: no edge
      return None
    elif weak_cls == 3: # 3:cn4r
      d['source'] = colname; d['dest'] = rowname
      d['directed'] = True
      d['is_weak'] = True
    elif weak_cls == 2:
      d['directed'] = True
      d['source'] = rowname; d['dest'] = colname
      d['is_weak'] = True
    else:
      d['directed'] = False
      d['source'] = rowname; d['dest'] = colname
      d['is_weak'] = True
  else:
    # edge goes from row to column (or is undirected)
    d['source'] = rowname; d['dest'] = colname
    d['directed'] = False

  # Edge Attributes
  # ------------------------------
  d['attr'] = {"penwidth":penwidth(cls,dcor), "color":'"%s"'%edgecolor(cls,dcor)}
  if weight is not None:
    d['attr']["weight"] = weight
  if cls == 0:
    d['attr'].update({'dir':"none", "constraint":"false", "style":"dotted"})
  elif cls == 2:
    d['attr'].update({'dir':"none", "constraint":"false"})
  elif cls == 4:
    if weak_cls is not None:
      # necessary direction edges
      if weak_cls == 2 or weak_cls == 3:
        d['attr'].update({"style":"dashed"})
      else:
        d['attr'].update({'dir':"none", "constraint":"false", "style":"dashed"})
    else:
      d['attr'].update({'dir':"none", "constraint":"false", "style":"dashed"})
      
  # RETURN EDGE DICT
  return d

def penwidth(c,d):
  """Return an edge pen width string from class `c` and dcor `d`."""
  assert c in BOOL_ENUM.keys(); assert d >= 0 and d <= 1
  if c==1 or c==3 or c==4:
    if d > 0.85:   return "1.5"
    else:          return "1.0"
  elif c == 2:
    if d > 0.9:    return "2.5"
    elif d > 0.8:  return "2.0"
    else:          return "1.5"
  else:
    return "1.0"

def edgecolor(c,d):
  """Return an edge color string from class `c` and dcor `d`."""
  assert c in BOOL_ENUM.keys(); assert d >= 0 and d <= 1
  if c == 0:
    return "#cccccc"
  elif c == 2:      # Positive Correlation (PC) class
    if d > 0.9:   return "#2688bf" # dark blue
    elif d > 0.8: return "#4197c7" # medium blue
    else:         return "#64acd4" # light blue
  elif c == 4:
    return "#888888"
  else:           # All other edges
    return "#222222"   # almost black

